<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Android 源码分析 —— Handler、Looper 和 MessageQueue &mdash; 码志</title><link rel="stylesheet" href="https://mazhuang.org/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://mazhuang.org/assets/css/components/collection.css"><link rel="stylesheet" href="https://mazhuang.org/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://mazhuang.org/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://mazhuang.org/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://mazhuang.org/assets/css/globals/common.css"><link rel="stylesheet" href="https://mazhuang.org/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://mazhuang.org/assets/css/posts/index.css"><link rel="stylesheet" href="https://mazhuang.org/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://mazhuang.org/rouge-themes/dist/github.css"><link rel="canonical" href="https://mazhuang.org/2018/06/11/handler-looper-massagequeue/"><link rel="alternate" type="application/atom+xml" title="码志" href="https://mazhuang.org/feed.xml"><link rel="shortcut icon" href="https://mazhuang.org/favicon.ico"><meta property="og:title" content="Android 源码分析 —— Handler、Looper 和 MessageQueue"><meta name="keywords" content="Android, Handler, Looper, Message, MessageQueue"><meta name="og:keywords" content="Android, Handler, Looper, Message, MessageQueue"><meta name="description" content="本系列文章在 https://github.com/mzlogin/rtfsc-android 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。"><meta name="og:description" content="本系列文章在 https://github.com/mzlogin/rtfsc-android 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。"><meta property="og:url" content="https://mazhuang.org/2018/06/11/handler-looper-massagequeue/"><meta property="og:site_name" content="码志"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2018-06-11"> <script src="https://mazhuang.org/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://mazhuang.org/assets/js/jquery-ui.js"></script> <script src="https://mazhuang.org/assets/js/main.js"></script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7093222719567591" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mazhuang.org/" title="码志"><span class="octicon octicon-mark-github"></span> 码志</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mazhuang.org/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://mazhuang.org/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://mazhuang.org/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://mazhuang.org/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://mazhuang.org/about/" class=" site-header-nav-item" target="" title="关于">关于</a> <a class="mobile-hidden" href="https://mazhuang.org/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Android 源码分析 ——"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Android 源码分析 —— Handler、Looper 和 MessageQueue</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2018/06/11 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mazhuang.org/categories/#Android" title="Android">Android</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 11261 字，约 33 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://mazhuang.org/assets/images/qrcode.jpg" alt="闷骚的程序员" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>本系列文章在 <a href="https://github.com/mzlogin/rtfsc-android">https://github.com/mzlogin/rtfsc-android</a> 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。</p><p>书接上文，在分析 Toast 源码的过程中我们涉及到了 Handler，这个在 Android 开发里经常用到的类——线程切换、顺序执行、延时执行等等逻辑里往往少不了它的身影，跟它一起搭配使用的通常是 Runnable 和 Message，还有它身后的好基友 Looper 与 MessageQueue。Runnable 相信大家都很熟悉了，本文的主角就是标题里的三剑客——Handler、Looper 和 MessageQueue，当然少不了说到 Message。</p><p>本文使用的工具与源码为：Chrome、插件 insight.io、GitHub 项目 <a href="https://github.com/aosp-mirror/platform_frameworks_base">aosp-mirror/platform_frameworks_base</a></p><p><strong>目录</strong></p><ul id="markdown-toc"><li><a href="#初步印象" id="markdown-toc-初步印象">初步印象</a><ul><li><a href="#handler" id="markdown-toc-handler">Handler</a></li><li><a href="#looper" id="markdown-toc-looper">Looper</a></li><li><a href="#messagequeue" id="markdown-toc-messagequeue">MessageQueue</a></li><li><a href="#message" id="markdown-toc-message">Message</a></li></ul></li><li><a href="#提出问题" id="markdown-toc-提出问题">提出问题</a></li><li><a href="#解答问题" id="markdown-toc-解答问题">解答问题</a><ul><li><a href="#thread-与-looper" id="markdown-toc-thread-与-looper">Thread 与 Looper</a></li><li><a href="#looper-与-messagequeue" id="markdown-toc-looper-与-messagequeue">Looper 与 MessageQueue</a></li><li><a href="#handler-与-looper" id="markdown-toc-handler-与-looper">Handler 与 Looper</a></li><li><a href="#消息如何分发到对应的-handler" id="markdown-toc-消息如何分发到对应的-handler">消息如何分发到对应的 Handler</a></li><li><a href="#handler-能用于线程切换的原理" id="markdown-toc-handler-能用于线程切换的原理">Handler 能用于线程切换的原理</a></li><li><a href="#runnable-与-messagequeue" id="markdown-toc-runnable-与-messagequeue">Runnable 与 MessageQueue</a></li><li><a href="#能否创建关联到其它线程的-handler" id="markdown-toc-能否创建关联到其它线程的-handler">能否创建关联到其它线程的 Handler</a></li><li><a href="#消息可以插队吗" id="markdown-toc-消息可以插队吗">消息可以插队吗</a></li><li><a href="#消息可以撤回吗" id="markdown-toc-消息可以撤回吗">消息可以撤回吗</a></li><li><a href="#找到主线程消息循环源码" id="markdown-toc-找到主线程消息循环源码">找到主线程消息循环源码</a></li></ul></li><li><a href="#总结" id="markdown-toc-总结">总结</a><ul><li><a href="#结论汇总" id="markdown-toc-结论汇总">结论汇总</a></li><li><a href="#遗留知识点" id="markdown-toc-遗留知识点">遗留知识点</a></li><li><a href="#本篇用到的源码分析方法" id="markdown-toc-本篇用到的源码分析方法">本篇用到的源码分析方法</a></li></ul></li><li><a href="#后话" id="markdown-toc-后话">后话</a></li></ul><h2 id="初步印象">初步印象</h2><p>按惯例，第一步还是从 Android 的官方 API 文档里来建立对这几个类的初步印象，文档开头的说明里往往有一些比较关键的知识点。</p><p>官方文档链接：</p><ul><li><a href="https://developer.android.google.cn/reference/android/os/Handler">Handler</a></li><li><a href="https://developer.android.google.cn/reference/android/os/Looper">Looper</a></li><li><a href="https://developer.android.google.cn/reference/android/os/MessageQueue">MessageQueue</a></li><li><a href="https://developer.android.google.cn/reference/android/os/Message">Message</a></li></ul><p>这几个类开头的说明本身也不长，为了避免断章取义误人子弟，就将其直译版完整地放在下面，当然更推荐的方式是自己去看原文。</p><h3 id="handler">Handler</h3><p>可以用 Handler 发送和处理与某线程的 MessageQueue 相关联的 Message/Runnable 对象。每个 Handler 实例只能与一个线程和它的消息队列相关联。当创建一个 Handler 时，它会绑定到当前线程和消息队列——从那时起，它将 Message 和 Runnable 传递给绑定的消息队列，并在它们从队列里被取出时执行对应逻辑。（<em>译注：此处描述不准确，创建 Handler 时并不一定是绑定到当前线程。</em>）</p><p>Handler 主要有两个用途：</p><ol><li><p>在未来某个时间点处理 Messages 或者执行 Runnables；</p></li><li><p>将一段逻辑切换到另一个线程执行。</p></li></ol><p>可以使用 Handler 的以下方法来调度 Messages 和 Runnables：</p><ul><li><p>post(Runnable)</p></li><li><p>postAtTime(Runnable, long)</p></li><li><p>postDelayed(Runnable, Object, long)</p></li><li><p>sendEmptyMessage(int)</p></li><li><p>sendMessage(Message)</p></li><li><p>sendMessageAtTime(Message, long)</p></li><li><p>sendMessageDelayed(Message, long)</p></li></ul><p>其中 postXXX 系列用于将 Runnable 对象加入队列，sendXXX 系列用于将 Message 对象加入队列，Message 对象通常会携带一些数据，可以在 Handler 的 handlerMessage(Message) 方法中处理（需要实现一个 Handler 子类）。</p><p>在调用 Handler 的 postXXX 和 sendXXX 时，可以指定当队列准备好时立即处理它们，也可以指定延时一段时间后处理，或某个绝对时间点处理。后面这两种能实现超时、延时、周期循环及其它基于时间的行为。</p><p>为应用程序创建一个进程时，其主线程专用于运行消息队列，该消息队列负责管理顶层应用程序对象（activities，broadcast receivers 等）以及它们创建的窗口。我们可以创建自己的线程，然后通过 Handler 与主线程进行通信，方法是从新线程调用我们前面讲到的 postXXX 或 sendXXX 方法，传递的 Runnable 或 Message 将被加入 Handler 关联的消息队列中，并适时进行处理。</p><h3 id="looper">Looper</h3><p>用于为线程执行消息循环的类。线程默认没有关联的消息循环，如果要创建一个，可以在执行消息循环的线程里面调用 prepare() 方法，然后调用 loop() 处理消息，直到循环停止。</p><p>大多数与消息循环的交互都是通过 Handler 类。</p><p>下面是实现一个 Looper 线程的典型例子，在 prepare() 和 loop() 之间初始化 Handler 实例，用于与 Looper 通信：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LooperThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Handler</span> <span class="n">mHandler</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Looper</span><span class="o">.</span><span class="na">prepare</span><span class="o">();</span>

        <span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Handler</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 在这里处理传入的消息</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">Looper</span><span class="o">.</span><span class="na">loop</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="messagequeue">MessageQueue</h3><p>持有将被 Looper 分发的消息列表的底层类。消息都是通过与 Looper 关联的 Handler 添加到 MessageQueue，而不是直接操作 MessageQueue。</p><p>可以用 Looper.myQueue() 获取当前线程的 MessageQueue 实例。</p><h3 id="message">Message</h3><p>定义一个可以发送给 Handler 的消息，包含描述和任意数据对象。消息对象有两个额外的 int 字段和一个 object 字段，这可以满足大部分场景的需求了。</p><blockquote><p>虽然 Message 的构造方法是 public 的，但最推荐的得到一个消息对象的方式是调用 Message.obtain() 或者 Handler.obtainMessage() 系列方法，这些方法会从一个对象回收池里捡回能复用的对象。</p></blockquote><h2 id="提出问题">提出问题</h2><p>根据以上印象，及以前的使用经验，提出以下问题来继续本次源码分析之旅：</p><ol><li><p>Thread 与 Looper，Looper 与 MessageQueue，Handler 与 Looper 之间的数量对应关系是怎样的？</p></li><li><p>如果 Looper 能对应多个 Handler，那通过不同的 Handler 发送的 Message，那处理的时候代码是如何知道该分发到哪一个 Handler 的 handlerMessage 方法的？</p></li><li><p>Handler 能用于线程切换的原理是什么？</p></li><li><p>Runnable 对象也是被添加到 MessageQueue 里吗？</p></li><li><p>可以在 A 线程创建 Handler 关联到 B 线程及其消息循环吗？</p></li><li><p>如何退出消息循环？</p></li><li><p>消息可以插队吗？</p></li><li><p>消息可以撤回吗？</p></li><li><p>上文提到，应用程序的主线程是运行一个消息循环，在代码里是如何反映的？</p></li></ol><h2 id="解答问题">解答问题</h2><h3 id="thread-与-looper">Thread 与 Looper</h3><p>前文有提到，线程默认是没有消息循环的，需要调用 Looper.prepare() 来达到目的，那么我们对这个问题的探索就从 Looper.prepare() 开始。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** Initialize the current thread as a looper.
 * This gives you a chance to create handlers that then reference
 * this looper, before actually starting the loop. Be sure to call
 * {@link #loop()} after calling this method, and end it by calling
 * {@link #quit()}.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">prepare</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Only one Looper may be created per thread"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">sThreadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">new</span> <span class="nc">Looper</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div><p>在有参数版本的 prepare 方法里，我们可以得到两个信息：</p><ol><li><p>一个线程里调用多次 Looper.prepare() 会抛出异常，提示 <code class="language-plaintext highlighter-rouge">Only one Looper may be created per thread</code>，即 <strong>一个线程只能创建一个 Looper</strong></p></li><li><p>prepare 里主要干的事就是 <code class="language-plaintext highlighter-rouge">sThreadLocal.set(new Looper(quitAllowed))</code></p></li></ol><p>源码里是怎么限制一个线程只能创建一个 Looper 的呢？调用多次 Looper.prepare() 并不会关联多个 Looper，还会抛出异常，那能不能直接 new 一个 Looper 关联上呢？答案是不可以，Looper 的构造方法是 private 的。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nf">Looper</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">mQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MessageQueue</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">);</span>
    <span class="n">mThread</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>在概览整个 Looper 的所有公开方法后，发现只有 prepare 和 prepareMainLooper 是做线程与 Looper 关联的工作的，而 prepareMainLooper 是 Android 环境调用的，不是用来给应用主动调用的。所以从 Looper 源码里掌握的信息来看，想给一个线程关联多个 Looper 的路不通。</p><p>另外我们从源码里能观察到，Looper 有一个 final 的 mThread 成员，在构造 Looper 对象的时候赋值为 <code class="language-plaintext highlighter-rouge">Thread.currentThread()</code>，源码里再无可以修改 mThread 值的地方，所以可知 <strong>Looper 只能关联到一个线程，且关联之后不能改变</strong>。</p><p>说了这么多，还记得 Looper.prepare() 里干的主要事情是 <code class="language-plaintext highlighter-rouge">sThreadLocal.set(new Looper(quitAllowed))</code> 吗？与之对应的，获取本线程关联的 Looper 对象是使用静态方法 Looper.myLooper()：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sThreadLocal.get() will return null unless you've called prepare().</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Looper</span><span class="o">&gt;</span> <span class="n">sThreadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Looper</span><span class="o">&gt;();</span>

<span class="c1">// ...</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Only one Looper may be created per thread"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">sThreadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">new</span> <span class="nc">Looper</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// ...</span>

<span class="cm">/**
 * Return the Looper object associated with the current thread.  Returns
 * null if the calling thread is not associated with a Looper.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nd">@Nullable</span> <span class="nc">Looper</span> <span class="nf">myLooper</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">sThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>使用了 ThreadLocal 来确保不同的线程调用静态方法 Looper.myLooper() 获取到的是与各自线程关联的 Looper 对象。关于 ThreadLocal，又可以另开一个小话题了。</p><p><strong>小结：</strong> Thread 若与 Looper 关联，将会是一一对应的关系，且关联后关系无法改变。</p><h3 id="looper-与-messagequeue">Looper 与 MessageQueue</h3><p>直接来看源码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Looper</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="kd">final</span> <span class="nc">MessageQueue</span> <span class="n">mQueue</span><span class="o">;</span>

    <span class="c1">// ...</span>

    <span class="kd">private</span> <span class="nf">Looper</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MessageQueue</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">);</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Looper 对象里有一个 MessageQueue 类型成员，在构造的时候 new 出的，并且它是一个 final，没有地方能修改它的指向。</p><p><strong>小结：</strong> Looper 与 MessageQueue 是一一对应的关系。</p><h3 id="handler-与-looper">Handler 与 Looper</h3><p>在前面略读 Looper 源码的过程中，我发现 Handler 基本没有出场，那么现在，从构造 Handler 的方法开始分析。</p><p>Handler 的构造方法有 7 个之多，不过有 3 个标记为 <code class="language-plaintext highlighter-rouge">@hide</code>，所以我们可以直接调用的有 4 个，这 4 个最终调用都到了其它的两个构造方法，捡出来我们要看的重点：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Handler</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    
    <span class="cm">/**
     * ...
     * @hide
     */</span>
    <span class="kd">public</span> <span class="nf">Handler</span><span class="o">(</span><span class="nc">Callback</span> <span class="n">callback</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">async</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ...</span>
        <span class="n">mLooper</span> <span class="o">=</span> <span class="nc">Looper</span><span class="o">.</span><span class="na">myLooper</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mLooper</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span>
                    <span class="s">"Can't create handler inside thread that has not called Looper.prepare()"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">mQueue</span> <span class="o">=</span> <span class="n">mLooper</span><span class="o">.</span><span class="na">mQueue</span><span class="o">;</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>

    <span class="cm">/**
     * ...
     * @hide
     */</span>
    <span class="kd">public</span> <span class="nf">Handler</span><span class="o">(</span><span class="nc">Looper</span> <span class="n">looper</span><span class="o">,</span> <span class="nc">Callback</span> <span class="n">callback</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">async</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mLooper</span> <span class="o">=</span> <span class="n">looper</span><span class="o">;</span>
        <span class="n">mQueue</span> <span class="o">=</span> <span class="n">mLooper</span><span class="o">.</span><span class="na">mQueue</span><span class="o">;</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>

    <span class="c1">// ...</span>

    <span class="kd">final</span> <span class="nc">Looper</span> <span class="n">mLooper</span><span class="o">;</span>
    <span class="kd">final</span> <span class="nc">MessageQueue</span> <span class="n">mQueue</span><span class="o">;</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><p>Handler 对象里有 final Looper 成员，所以一个 Handler 只会对应一个固定的 Looper 对象。构造 Handler 对象的时候如果不传 Looper 参数，会默认使用当前线程关联的 Looper，如果当前线程没有关联 Looper，会抛出异常。</p><p>那么能不能绑定多个 Handler 到同一个 Looper 呢？答案是可以的。在源码里并没有找到相关的限制说明，所以这种适合用个小 Demo 来验证，例如以下例子，就绑定了两个 Handler 到主线程的 Looper 上，并都能正常使用（日志 <code class="language-plaintext highlighter-rouge">receive msg: 1</code> 和 <code class="language-plaintext highlighter-rouge">receive msg: 2</code> 能依次输出）。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="nc">AppCompatActivity</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">TAG</span> <span class="o">=</span> <span class="nc">MainActivity</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">();</span>

    <span class="kd">private</span> <span class="nc">Handler</span> <span class="n">mHandler1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Handler</span> <span class="n">mHandler2</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Handler</span><span class="o">.</span><span class="na">Callback</span> <span class="n">mCallback</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Handler</span><span class="o">.</span><span class="na">Callback</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="no">TAG</span><span class="o">,</span> <span class="s">"receive msg: "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">.</span><span class="na">what</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="nc">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="no">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_main</span><span class="o">);</span>

        <span class="n">mHandler1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Handler</span><span class="o">(</span><span class="n">mCallback</span><span class="o">);</span>
        <span class="n">mHandler2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Handler</span><span class="o">(</span><span class="n">mCallback</span><span class="o">);</span>

        <span class="n">mHandler1</span><span class="o">.</span><span class="na">sendEmptyMessage</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">mHandler2</span><span class="o">.</span><span class="na">sendEmptyMessage</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>小结：</strong> Handler 与 Looper 是多对一的关系，创建 Handler 实例时要么提供一个 Looper 实例，要么当前线程有关联的 Looper。</p><h3 id="消息如何分发到对应的-handler">消息如何分发到对应的 Handler</h3><p>因为消息的分发在是 Looper.loop() 这个过程中，所以我们先来看这个方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="nc">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">next</span><span class="o">();</span> <span class="c1">// might block</span>
        <span class="c1">// ...</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">dispatchMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
            <span class="c1">// ...</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="c1">// ...</span>
        <span class="o">}</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这个方法里做的主要工作是从 MessageQueue 里依次取出 Message，然后调用 Message.target.dispatchMessage 方法，Message 对象的这个 target 成员是什么东东呢？它是一个 Handler，它最终会被设置成 sendMessage 的 Handler：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Handler</span> <span class="o">{</span>
    <span class="c1">// 其它 Handler.sendXXX 方法最终都会调用到这个方法</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">sendMessageAtTime</span><span class="o">(</span><span class="nc">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ...</span>
        <span class="k">return</span> <span class="nf">enqueueMessage</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="n">msg</span><span class="o">,</span> <span class="n">uptimeMillis</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="o">(</span><span class="nc">MessageQueue</span> <span class="n">queue</span><span class="o">,</span> <span class="nc">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span> <span class="c1">// 就是这里了</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><p>所以是用哪个 Handler.sendMessage，最终就会调用到它的 dispatchMessage 方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">handleCallback</span><span class="o">(</span><span class="nc">Message</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">message</span><span class="o">.</span><span class="na">callback</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
<span class="o">}</span>
<span class="c1">// ...</span>
<span class="cm">/**
 * Handle system messages here.
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">dispatchMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">callback</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handleCallback</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mCallback</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mCallback</span><span class="o">.</span><span class="na">handleMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">handleMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>消息分发到这个方法以后，执行优先级分别是 Message.callback、Handler.mCallback，最后才是 Handler.handleMesage 方法。</p><p><strong>小结：</strong> 在 Handler.sendMessage 时，会将 Message.target 设置为该 Handler 对象，这样从消息队列取出 Message 后，就能调用到该 Handler 的 dispatchMessage 方法来进行处理。</p><h3 id="handler-能用于线程切换的原理">Handler 能用于线程切换的原理</h3><p>实际上一小节的结论已经近乎揭示了其中的原理，进一步解释一下就是：</p><p><strong>小结：</strong> Handler 会对应一个 Looper 和 MessageQueue，而 Looper 与线程又一一对应，所以通过 Handler.sendXXX 和 Hanler.postXXX 添加到 MessageQueue 的 Message，会在这个对应的线程的 Looper.loop() 里取出来，并就地执行 Handler.dispatchMessage，这就可以完成线程切换了。</p><h3 id="runnable-与-messagequeue">Runnable 与 MessageQueue</h3><p>Handler 的 postXXX 系列方法用于调度 Runnable 对象，那它最后也是和 Message 一样被加到 MessageQueue 的吗？可是 MessageQueue 是用一个元素类型为 Message 的链表来维护消息队列的，类型不匹配。</p><p>在 Handler 源码里能找到答案，这里就以 Handler.post(Runnable) 方法为例，其它几个 postXXX 方法情形与此类似。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Causes the Runnable r to be added to the message queue.
 * The runnable will be run on the thread to which this handler is 
 * attached. 
 *  
 * @param r The Runnable that will be executed.
 * 
 * @return Returns true if the Runnable was successfully placed in to the 
 *         message queue.  Returns false on failure, usually because the
 *         looper processing the message queue is exiting.
 */</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">post</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span>  <span class="nf">sendMessageDelayed</span><span class="o">(</span><span class="n">getPostMessage</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ...</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Message</span> <span class="nf">getPostMessage</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Message</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">Message</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
    <span class="n">m</span><span class="o">.</span><span class="na">callback</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>可以看到，post 系列方法最终也是调用的 send 系列方法，Runnable 对象是被封装成 Message 对象后加入到消息队列的，Message.callback 被设置为 Runnable 本身，还记得前文 Handler.dispatchMessage 的执行顺序吗？如果 Message.callback 不为空，则执行 Message.callback.run() 后就返回。</p><p><strong>小结：</strong> Runnable 被封装成 Message 之后添加到 MessageQueue。</p><h3 id="能否创建关联到其它线程的-handler">能否创建关联到其它线程的 Handler</h3><p>创建 Handler 时会关联到一个 Looper，而 Looper 是与线程一一绑定的，所以理论上讲，如果能得到要关联的线程的 Looper 实例，这是可以实现的。</p><p>在阅读 Looper 源码的过程中，我们有留意到（好吧，其实应该是平时写代码时有用到）：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Looper</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Looper</span> <span class="n">sMainLooper</span><span class="o">;</span>  <span class="c1">// guarded by Looper.class</span>
    <span class="c1">// ...</span>
    <span class="cm">/**
     * Returns the application's main looper, which lives in the main thread of the application.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Looper</span> <span class="nf">getMainLooper</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Looper</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">sMainLooper</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>可见获取主线程的 Looper 是能实现的，平时写代码过程中，如果要从子线程向主线程添加一段执行逻辑，也经常这么干，这是可行的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 从子线程创建关联到主线程 Looper 的 Handler</span>
<span class="nc">Handler</span> <span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Handler</span><span class="o">(</span><span class="nc">Looper</span><span class="o">.</span><span class="na">getMainLooper</span><span class="o">());</span>

<span class="n">mHandler</span><span class="o">.</span><span class="na">post</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">// ...</span>
        <span class="o">});</span>
</code></pre></div></div><p>从子线程创建关联到其它子线程的 Looper 是否可行呢？这个用 Demo 来验证：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">Thread</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setName</span><span class="o">(</span><span class="s">"thread-one"</span><span class="o">);</span>
        <span class="nc">Looper</span><span class="o">.</span><span class="na">prepare</span><span class="o">();</span>

        <span class="kd">final</span> <span class="nc">Looper</span> <span class="n">threadOneLooper</span> <span class="o">=</span> <span class="nc">Looper</span><span class="o">.</span><span class="na">myLooper</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">setName</span><span class="o">(</span><span class="s">"thread-two"</span><span class="o">);</span>
                <span class="nc">Handler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Handler</span><span class="o">(</span><span class="n">threadOneLooper</span><span class="o">);</span>

                <span class="n">handler</span><span class="o">.</span><span class="na">post</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                        <span class="nc">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="s">"test"</span><span class="o">,</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
                        <span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>

        <span class="nc">Looper</span><span class="o">.</span><span class="na">loop</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div><p>执行后日志输出为 <code class="language-plaintext highlighter-rouge">thread-one</code>。</p><p><strong>小结：</strong> 可以从一个线程创建关联到另一个线程 Looper 的 Handler，只要能拿到对应线程的 Looper 实例。</p><h3 id="消息可以插队吗">消息可以插队吗</h3><p>这个问题从API 文档、Handler 源码里都可以找到答案，答案是可以的，使用 Handler.sendMessageAtFrontOfQueue 和 Handler.postAtFrontOfQueue 这两个方法，它们会分别将 Message 和 Runnable（封装后）插入到消息队列的队首。</p><p>我目前尚未遇到过这种使用场景。</p><p><strong>小结：</strong> 消息可以插队，使用 Handler.xxxAtFrontOfQueue 方法。</p><h3 id="消息可以撤回吗">消息可以撤回吗</h3><p>同上，可以从 Handler 的 API 文档中找到答案。</p><p>可以用 Handler.hasXXX 系列方法判断关联的消息队列里是否有等待中的符合条件的 Message 和 Runnable，用 Handler.removeXXX 系列方法从消息队列里移除等待中的符合条件的 Message 和 Runnable。</p><p><strong>小结：</strong> 尚未分发的消息是可以撤回的，处理过的就没法了。</p><h3 id="找到主线程消息循环源码">找到主线程消息循环源码</h3><p>我们前面提到过一个小细节，就是 Looper.prepareMainLooper 是 Android 环境调用的，而从该方法的注释可知，调用它就是为了初始化主线程 Looper，所以我们要找到主线程消息循环这部分源码，搜索 prepareMainLooper 被哪些地方引用即可。</p><p>使用 insight.io 插件的功能，在 Looper.prepareMainLooper 上点一下即可看到引用处列表，一共两处：</p><p><img src="https://mazhuang.org/images/posts/android/prepare-main-looper.png" alt="" /></p><p>从文件路径和文件名上猜测应该是第一处。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ActivityThread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ...</span>
        <span class="nc">Looper</span><span class="o">.</span><span class="na">prepareMainLooper</span><span class="o">();</span>
        <span class="c1">// ...</span>
        <span class="nc">Looper</span><span class="o">.</span><span class="na">loop</span><span class="o">();</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>就是我想象中的模样。这里只是简单找到这个位置，继续深入探索的话可以开启一个新的话题了，后续的篇章里再解决。</p><h2 id="总结">总结</h2><h3 id="结论汇总">结论汇总</h3><ul><li><p>Thread 若与 Looper 关联，将会是一一对应的关系，且关联后关系无法改变。</p></li><li><p>Looper 与 MessageQueue 是一一对应的关系。</p></li><li><p>Handler 与 Looper 是多对一的关系，创建 Handler 实例时要么提供一个 Looper 实例，要么当前线程有关联的 Looper。</p></li><li><p>在 Handler.sendMessage 时，会将 Message.target 设置为该 Handler 对象，这样从消息队列取出 Message 后，就能调用到该 Handler 的 dispatchMessage 方法来进行处理。</p></li><li><p>Handler 会对应一个 Looper 和 MessageQueue，而 Looper 与线程又一一对应，所以通过 Handler.sendXXX 和 Hanler.postXXX 添加到 MessageQueue 的 Message，会在这个对应的线程的 Looper.loop() 里取出来，并就地执行 Handler.dispatchMessage，这就可以完成线程切换了。</p></li><li><p>Runnable 被封装成 Message 之后添加到 MessageQueue。</p></li><li><p>可以从一个线程创建关联到另一个线程 Looper 的 Handler，只要能拿到对应线程的 Looper 实例。</p></li><li><p>消息可以插队，使用 Handler.xxxAtFrontOfQueue 方法。</p></li><li><p>尚未分发的消息是可以撤回的，处理过的就没法了。</p></li></ul><h3 id="遗留知识点">遗留知识点</h3><ol><li><p>ThreadLocal</p></li><li><p>应用的启动流程</p></li></ol><h3 id="本篇用到的源码分析方法">本篇用到的源码分析方法</h3><ol><li>文档优先</li></ol><h2 id="后话">后话</h2><p>关于 Handler、Looper 和 MessageQueue 的分析在此先告一段落，这部分的内容比较容易分析，但里面细节挺多的，写得有点杂且不全，有点只见树木不见森林的感觉，想要配合画一些图，但找不到合适的画图形式。对此类主题的解析方式必须要再探索优化一下，大家有好的建议请一定告知。</p><hr /><p>最后，照例要安利一下我的微信公众号「闷骚的程序员」，扫码关注，接收 rtfsc-android 的最近更新。</p><div align="center"><img width="192px" height="192px" src="https://mazhuang.org/assets/images/qrcode.jpg" /></div><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://mazhuang.org" target="_blank">Zhuang Ma</a></li><li>本文链接：<a href="https://mazhuang.org/2018/06/11/handler-looper-massagequeue/" target="_blank">https://mazhuang.org/2018/06/11/handler-looper-massagequeue/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://giscus.app/client.js" data-repo="mzlogin/blog-comments" data-repo-id="MDEwOlJlcG9zaXRvcnk5MzEyNzkxNw==" data-category="Announcements" data-category-id="DIC_kwDOBY0E7c4CRtg9" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://mazhuang.org/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://mazhuang.org/assets/search_data.json?v=1669204461', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://mazhuang.org/assets/js/jquery.toc.js"></script> <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-7093222719567591" data-ad-slot="5337165236"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-format="autorelaxed" data-ad-client="ca-pub-7093222719567591" data-ad-slot="9073246172"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Zhuang Ma">Zhuang Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/mzlogin/mzlogin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mazhuang.org/" title="首页" target="">首页</a></li><li> <a href="https://mazhuang.org/categories/" title="分类" target="">分类</a></li><li> <a href="https://mazhuang.org/wiki/" title="维基" target="">维基</a></li><li> <a href="https://mazhuang.org/links/" title="链接" target="">链接</a></li><li> <a href="https://mazhuang.org/about/" title="关于" target="">关于</a></li><li><a href="https://mazhuang.org/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://mazhuang.org/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
